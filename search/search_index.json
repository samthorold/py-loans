{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Year Starting Loan Interest Payment Ending Loan 0 100 5 7 98 1 98 5 7 96 <p>APRC: annual percentage rate of charge. The total value of principal + interest + other fees expressed as an annual percentage.</p> <p>There is an interest rate process that is contractually, or assumed to be, fixed for typically 3 different time periods of the mortgage's term.</p> <ul> <li>Fixed term: e.g. 24 months at a low introductory offer</li> <li>Intermediary term: e.g. 12 months at a higher rate</li> <li>Remainder: e.g. 264 months at another rate.</li> </ul> <p>The total cost of the mortgage is calculated by finding the implied flat payment across each term.</p> <ol> <li>Find the start value of the term using the payments over the prior calculated period at the new interest rate.</li> <li>Find the flat payment assuming the new interest rate over the remainder of the loan.</li> </ol>"},{"location":"#py_loans.loan","title":"py_loans.loan","text":""},{"location":"#py_loans.loan.IllustrativeMortgage","title":"IllustrativeMortgage","text":"<p>             Bases: <code>BaseModel</code></p> <p>Illustrative mortgage repayment schedule.</p> <p>Assumes constant payments and interest rates over a series of time periods.</p> <p>Attributes:</p> Name Type Description <code>start_value</code> <code>NonNegativeFloat</code> <p>Loan amount at the outset.</p> <code>loan_terms</code> <code>list[LoanTerm]</code> <p>The periods of constant payments and interest rates.</p> <code>repayment_period</code> <code>PositiveInt</code> <p>Number of time steps until the loan matures.</p> Source code in <code>py_loans/loan.py</code> <pre><code>class IllustrativeMortgage(BaseModel):\n\"\"\"Illustrative mortgage repayment schedule.\n\n    Assumes constant payments and interest rates over a series of time periods.\n\n    Attributes:\n        start_value: Loan amount at the outset.\n        loan_terms: The periods of constant payments and interest rates.\n        repayment_period: Number of time steps until the loan matures.\n\n    \"\"\"\n\n    start_value: NonNegativeFloat\n    loan_terms: list[LoanTerm]\n    repayment_period: PositiveInt = 300\n\n    @field_validator(\"loan_terms\")\n    def validate_loan_terms(cls, v: list[LoanTerm]) -&gt; list[LoanTerm]:\n        if not v:\n            raise ValueError(\"Must provide at least one loan term.\")\n        return v\n\n    def calculate(self) -&gt; RepaymentSchedule:\n        start_value = self.start_value\n        loan_terms = self.loan_terms\n        repayment_period = self.repayment_period\n\n        time_step = 0\n        loan_periods: list[RepaymentPeriod] = []\n\n        for lidx, loan_term in enumerate(loan_terms):\n            term_rate = convert_rate(\n                rate=loan_term.rate,\n                from_period=loan_term.from_period,\n                to_period=loan_term.to_period,\n                simple=loan_term.simple,\n            )\n\n            # find the start value of the current period\n            if lidx:\n                time_step = sum(lt.term for lt in loan_terms[:lidx])\n                start_value = loan_periods[time_step - 1].end_value\n                loan_periods = loan_periods[:time_step]\n\n            # find the flat payment assuming the new interest rate for the\n            # remainder of the loan\n            payment = find_flat_payment(\n                start_value=start_value,\n                interest_rate_process=term_rate,\n                time_step=time_step,\n                repayment_period=repayment_period,\n                tol=1e-5,\n            )\n\n            loan_periods += list(\n                loan(\n                    start_value=start_value,\n                    interest_rate_process=term_rate,\n                    payment_process=payment,\n                    time_step=time_step,\n                    repayment_period=repayment_period,\n                )\n            )\n\n        return RepaymentSchedule(periods=loan_periods)\n</code></pre>"},{"location":"#py_loans.loan.LoanTerm","title":"LoanTerm","text":"<p>             Bases: <code>BaseModel</code></p> <p>Description of a period of a loan with a fixed interest rate.</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>float</code> <p>Interest rate.</p> <code>term</code> <code>PositiveInt</code> <p>Length in periods of the LoanTerm.</p> <code>to_period</code> <code>PositiveInt</code> <p>How many times a year the rate compounds.</p> <code>simple</code> <code>bool</code> <p>Does the rate get converted using a simple or equivalent rate?</p> Source code in <code>py_loans/loan.py</code> <pre><code>class LoanTerm(BaseModel):\n\"\"\"Description of a period of a loan with a fixed interest rate.\n\n    Attributes:\n        rate: Interest rate.\n        term: Length in periods of the LoanTerm.\n        to_period: How many times a year the rate compounds.\n        simple: Does the rate get converted using a simple or equivalent rate?\n    \"\"\"\n\n    rate: float\n    term: PositiveInt\n    from_period: PositiveInt = 1\n    to_period: PositiveInt = 12\n    simple: bool = True\n</code></pre>"},{"location":"#py_loans.loan.RepaymentPeriod","title":"RepaymentPeriod","text":"<p>             Bases: <code>BaseModel</code></p> <p>A single time step in a loan repayment schedule.</p> <p>Attributes:</p> Name Type Description <code>time_step</code> <code>NonNegativeInt</code> <p>Time index this step corresponds to.</p> <code>start_value</code> <code>float</code> <p>Loan amount at the beginning of the period.</p> <code>interest</code> <code>float</code> <p>Interest payable on the loan this period.</p> <code>payment</code> <code>NonNegativeFloat</code> <p>Payment made for this period. Greater than or equal to the interest.</p> <code>end_value</code> <code>NonNegativeFloat</code> <p>Loan amount at the end of this period.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lp = RepaymentPeriod(\n...     time_step=0,\n...     start_value=100,\n...     interest=5,\n...     payment=7,\n... )\n&gt;&gt;&gt; lp.end_value\n98.0\n&gt;&gt;&gt; lp = RepaymentPeriod(\n...     time_step=0,\n...     start_value=100,\n...     interest=5,\n...     payment=4,\n... )\n&gt;&gt;&gt; lp.payment\n5.0\n</code></pre> Source code in <code>py_loans/loan.py</code> <pre><code>class RepaymentPeriod(BaseModel):\n\"\"\"A single time step in a loan repayment schedule.\n\n    Attributes:\n        time_step: Time index this step corresponds to.\n        start_value: Loan amount at the beginning of the period.\n        interest: Interest payable on the loan this period.\n        payment: Payment made for this period. Greater than or equal to the interest.\n        end_value: Loan amount at the end of this period.\n\n    Examples:\n\n        &gt;&gt;&gt; lp = RepaymentPeriod(\n        ...     time_step=0,\n        ...     start_value=100,\n        ...     interest=5,\n        ...     payment=7,\n        ... )\n        &gt;&gt;&gt; lp.end_value\n        98.0\n        &gt;&gt;&gt; lp = RepaymentPeriod(\n        ...     time_step=0,\n        ...     start_value=100,\n        ...     interest=5,\n        ...     payment=4,\n        ... )\n        &gt;&gt;&gt; lp.payment\n        5.0\n\n\n    \"\"\"\n\n    time_step: NonNegativeInt\n    start_value: float\n    interest: float\n    payment: NonNegativeFloat\n\n    @field_validator(\"payment\")\n    def validate_payment_amount(\n        cls, v: NonNegativeFloat, info: FieldValidationInfo\n    ) -&gt; NonNegativeFloat:\n        interest: NonNegativeFloat = info.data[\"interest\"]\n        return max(v, interest)\n\n    @computed_field  # type: ignore[misc]\n    @property\n    def end_value(self) -&gt; NonNegativeFloat:\n        return self.start_value + self.interest - self.payment\n</code></pre>"},{"location":"#py_loans.loan.convert_rate","title":"convert_rate","text":"<pre><code>convert_rate(\n    rate, from_period=1.0, to_period=12, simple=True\n)\n</code></pre> <p>Convert an interest rate over one period to an equivalent rate over another period.</p> <p><code>(1 + j)**to_period == (1 + i)**from_period</code></p> <p><code>j == (1 + i)**(from_period/to_period) - 1</code></p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>float</code> <p>Rate to convert.</p> required <code>from_period</code> <code>float</code> <p>Number of times the rate compounds.</p> <code>1.0</code> <code>to_period</code> <code>float</code> <p>Number of times the equivalent rate compounds.</p> <code>12</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rate = convert_rate(0.05, 1, 12, simple=False)\n&gt;&gt;&gt; round(rate, 4)\n0.0041\n&gt;&gt;&gt; rate = convert_rate(rate, 12, 1, simple=False)\n&gt;&gt;&gt; round(rate, 12)\n0.05\n</code></pre> Source code in <code>py_loans/loan.py</code> <pre><code>def convert_rate(\n    rate: float, from_period: float = 1.0, to_period: float = 12, simple: bool = True\n) -&gt; float:\n\"\"\"Convert an interest rate over one period to an equivalent rate over another period.\n\n    `(1 + j)**to_period == (1 + i)**from_period`\n\n    `j == (1 + i)**(from_period/to_period) - 1`\n\n    Arguments:\n        rate: Rate to convert.\n        from_period: Number of times the rate compounds.\n        to_period: Number of times the equivalent rate compounds.\n\n    Examples:\n        &gt;&gt;&gt; rate = convert_rate(0.05, 1, 12, simple=False)\n        &gt;&gt;&gt; round(rate, 4)\n        0.0041\n        &gt;&gt;&gt; rate = convert_rate(rate, 12, 1, simple=False)\n        &gt;&gt;&gt; round(rate, 12)\n        0.05\n\n    \"\"\"\n    if simple:\n        return rate * from_period / to_period\n    return float((1 + rate) ** (from_period / to_period) - 1)\n</code></pre>"},{"location":"#py_loans.loan.find_flat_payment","title":"find_flat_payment","text":"<pre><code>find_flat_payment(\n    start_value,\n    interest_rate_process,\n    repayment_period,\n    time_step=0,\n    tol=1e-05,\n)\n</code></pre> <p>Find the flat payment such that a loan is paid off at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>start_value</code> <code>NonNegativeFloat</code> <p>Loan amount at the outset.</p> required <code>interest_rate_process</code> <code>Process | float</code> <p>Process governing the interest rate at each time step.</p> required <code>repayment_period</code> <code>NonNegativeInt</code> <p>Number of time steps until the loan matures.</p> required <code>time_step</code> <code>NonNegativeInt</code> <p>Begining time step.</p> <code>0</code> <code>tol</code> <code>float</code> <p>Tolerance within which the root finding algorithm has converged.</p> <code>1e-05</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payment = find_flat_payment(\n... start_value=100,\n... interest_rate_process=0.0,\n... repayment_period=25,\n... tol=0.01,\n... )\n&gt;&gt;&gt; round(payment, 2)\n4.0\n&gt;&gt;&gt; payment = find_flat_payment(\n... start_value=100,\n... interest_rate_process=0.05,\n... repayment_period=25,\n... tol=0.01,\n... )\n&gt;&gt;&gt; round(payment, 2)\n7.1\n</code></pre> Source code in <code>py_loans/loan.py</code> <pre><code>def find_flat_payment(\n    start_value: NonNegativeFloat,\n    interest_rate_process: Process | float,\n    repayment_period: NonNegativeInt,\n    time_step: NonNegativeInt = 0,\n    tol: float = 1e-5,\n) -&gt; float:\n\"\"\"Find the flat payment such that a loan is paid off at maturity.\n\n    Arguments:\n        start_value: Loan amount at the outset.\n        interest_rate_process: Process governing the interest rate at each time step.\n        repayment_period: Number of time steps until the loan matures.\n        time_step: Begining time step.\n        tol: Tolerance within which the root finding algorithm has converged.\n\n    Examples:\n\n        &gt;&gt;&gt; payment = find_flat_payment(\n        ... start_value=100,\n        ... interest_rate_process=0.0,\n        ... repayment_period=25,\n        ... tol=0.01,\n        ... )\n        &gt;&gt;&gt; round(payment, 2)\n        4.0\n        &gt;&gt;&gt; payment = find_flat_payment(\n        ... start_value=100,\n        ... interest_rate_process=0.05,\n        ... repayment_period=25,\n        ... tol=0.01,\n        ... )\n        &gt;&gt;&gt; round(payment, 2)\n        7.1\n\n    \"\"\"\n\n    def objective_func(flat_payment: float) -&gt; float:\n        loan_gen = loan(\n            start_value=start_value,\n            interest_rate_process=interest_rate_process,\n            payment_process=ConstantValue(value=flat_payment),\n            time_step=time_step,\n            repayment_period=repayment_period,\n        )\n        repayment = list(loan_gen)\n        return repayment[-1].end_value\n\n    root = bisect(objective_func, a=0, b=start_value, tol=tol)\n\n    if not root.converged:\n        raise ValueError(f\"Could not find payment. {root}\")\n\n    return root.value\n</code></pre>"},{"location":"#py_loans.loan.loan","title":"loan","text":"<pre><code>loan(\n    start_value,\n    interest_rate_process,\n    payment_process,\n    time_step=0,\n    repayment_period=25,\n)\n</code></pre> <p>Generate loan repayments until the term of the loan.</p> <p>Parameters:</p> Name Type Description Default <code>start_value</code> <code>NonNegativeFloat</code> <p>Loan amount at the outset.</p> required <code>interest_rate_process</code> <code>Process | float</code> <p>Process governing the interest rate at each time step.</p> required <code>payment_process</code> <code>Process | float</code> <p>Process governing the payments at each time step.</p> required <code>time_step</code> <code>NonNegativeInt</code> <p>Begining time step.</p> <code>0</code> <code>repayment_period</code> <code>NonNegativeInt</code> <p>Number of time steps until the loan matures.</p> <code>25</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; repayment_process = loan(\n... start_value=100,\n... interest_rate_process=0.05,\n... payment_process=7,\n... )\n&gt;&gt;&gt; next(repayment_process)\nRepaymentPeriod(time_step=0, start_value=100.0, interest=5.0, payment=7.0, end_value=98.0)\n&gt;&gt;&gt; next(repayment_process)\nRepaymentPeriod(time_step=1, start_value=98.0, interest=4.9, payment=7.0, end_value=95.9)\n</code></pre> Source code in <code>py_loans/loan.py</code> <pre><code>def loan(\n    start_value: NonNegativeFloat,\n    interest_rate_process: Process | float,\n    payment_process: Process | float,\n    time_step: NonNegativeInt = 0,\n    repayment_period: NonNegativeInt = 25,\n) -&gt; Iterator[RepaymentPeriod]:\n\"\"\"Generate loan repayments until the term of the loan.\n\n    Arguments:\n        start_value: Loan amount at the outset.\n        interest_rate_process: Process governing the interest rate at each time step.\n        payment_process: Process governing the payments at each time step.\n        time_step: Begining time step.\n        repayment_period: Number of time steps until the loan matures.\n\n    Examples:\n\n        &gt;&gt;&gt; repayment_process = loan(\n        ... start_value=100,\n        ... interest_rate_process=0.05,\n        ... payment_process=7,\n        ... )\n        &gt;&gt;&gt; next(repayment_process)\n        RepaymentPeriod(time_step=0, start_value=100.0, interest=5.0, payment=7.0, end_value=98.0)\n        &gt;&gt;&gt; next(repayment_process)\n        RepaymentPeriod(time_step=1, start_value=98.0, interest=4.9, payment=7.0, end_value=95.9)\n    \"\"\"\n\n    if isinstance(interest_rate_process, (int, float)):\n        interest_rate_process = ConstantValue(value=interest_rate_process)\n    if isinstance(payment_process, (int, float)):\n        payment_process = ConstantValue(value=payment_process)\n\n    while True:\n        month = RepaymentPeriod(\n            time_step=time_step,\n            start_value=start_value,\n            interest=start_value * interest_rate_process.step(time_step),\n            payment=payment_process.step(time_step),\n        )\n        yield month\n\n        if month.time_step &gt;= (repayment_period - 1):\n            break\n\n        time_step = time_step + 1\n        start_value = month.end_value\n</code></pre>"},{"location":"#py_loans.process","title":"py_loans.process","text":"<p>Dynamic processes governing loan interest and payment amounts over time.</p>"},{"location":"#py_loans.process.ConstantValue","title":"ConstantValue","text":"<p>             Bases: <code>BaseModel</code></p> <p>Process that returns the same value every time step.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>NonNegativeFloat</code> <p>Constant value to return every time step.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; process = ConstantValue(value=7)\n&gt;&gt;&gt; process.step(0)\n7.0\n&gt;&gt;&gt; process.step(100)\n7.0\n</code></pre> Source code in <code>py_loans/process.py</code> <pre><code>class ConstantValue(BaseModel):\n\"\"\"Process that returns the same value every time step.\n\n    Attributes:\n        value: Constant value to return every time step.\n\n    Examples:\n        &gt;&gt;&gt; process = ConstantValue(value=7)\n        &gt;&gt;&gt; process.step(0)\n        7.0\n        &gt;&gt;&gt; process.step(100)\n        7.0\n\n\n    \"\"\"\n\n    value: NonNegativeFloat\n\n    def step(self, t: NonNegativeInt) -&gt; float:\n\"\"\"Return the constant value.\"\"\"\n        return self.value\n</code></pre>"},{"location":"#py_loans.process.ConstantValue.step","title":"step","text":"<pre><code>step(t)\n</code></pre> <p>Return the constant value.</p> Source code in <code>py_loans/process.py</code> <pre><code>def step(self, t: NonNegativeInt) -&gt; float:\n\"\"\"Return the constant value.\"\"\"\n    return self.value\n</code></pre>"},{"location":"#py_loans.process.Process","title":"Process","text":"<p>             Bases: <code>Protocol</code></p> <p>Interface defining a Process.</p> Source code in <code>py_loans/process.py</code> <pre><code>class Process(Protocol):\n\"\"\"Interface defining a Process.\"\"\"\n\n    def step(self, t: NonNegativeInt) -&gt; float:\n\"\"\"Process value for this time step.\n\n        Arguments:\n            t: Time step.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"#py_loans.process.Process.step","title":"step","text":"<pre><code>step(t)\n</code></pre> <p>Process value for this time step.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NonNegativeInt</code> <p>Time step.</p> required Source code in <code>py_loans/process.py</code> <pre><code>def step(self, t: NonNegativeInt) -&gt; float:\n\"\"\"Process value for this time step.\n\n    Arguments:\n        t: Time step.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"#py_loans.roots","title":"py_loans.roots","text":"<p>Root finding algorithms for calculating payment amounts for a given loan term.</p>"},{"location":"#py_loans.roots.Root","title":"Root","text":"<p>             Bases: <code>BaseModel</code></p> <p>Result of a root-finding algorithm.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The root.</p> <code>iterations</code> <code>int</code> <p>How many iterations it took to find the root.</p> <code>converged</code> <code>bool</code> <p>Did the algorithm converge?</p> <code>tol</code> <code>float</code> <p>The tolerance used to find the root.</p> Source code in <code>py_loans/roots.py</code> <pre><code>class Root(BaseModel):\n\"\"\"Result of a root-finding algorithm.\n\n    Attributes:\n        value: The root.\n        iterations: How many iterations it took to find the root.\n        converged: Did the algorithm converge?\n        tol: The tolerance used to find the root.\n\n    \"\"\"\n\n    value: float\n    iterations: int\n    converged: bool\n    tol: float\n</code></pre>"},{"location":"#py_loans.roots.bisect","title":"bisect","text":"<pre><code>bisect(f, a, b, tol, max_iterations=50)\n</code></pre> <p>Bisection root-finding algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[float], float]</code> <p>Objective function.</p> required <code>a</code> <code>float</code> <p>Left of the initial search interval.</p> required <code>b</code> <code>float</code> <p>Right of the initial search interval.</p> required <code>tol</code> <code>float</code> <p>Maximum distance between a and b or value of <code>f((a+b)/2)</code>.</p> required <code>max_iterations</code> <code>int</code> <p>Maximum iterations without convergence.</p> <code>50</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bisect(f=lambda x: x*x - 4, a=0, b=4, tol=0.001)\nRoot(value=2.0, iterations=0, converged=True, tol=0.001)\n&gt;&gt;&gt; root = bisect(\n... f=lambda x: x*x*x + 8, a=-7, b=-1, tol=1e-25, max_iterations=100\n... )\n&gt;&gt;&gt; root.value\n-2.0\n&gt;&gt;&gt; root.converged\nTrue\n</code></pre> Source code in <code>py_loans/roots.py</code> <pre><code>def bisect(\n    f: Callable[[float], float],\n    a: float,\n    b: float,\n    tol: float,\n    max_iterations: int = 50,\n) -&gt; Root:\n\"\"\"Bisection root-finding algorithm.\n\n    Arguments:\n        f: Objective function.\n        a: Left of the initial search interval.\n        b: Right of the initial search interval.\n        tol: Maximum distance between a and b or value of `f((a+b)/2)`.\n        max_iterations: Maximum iterations without convergence.\n\n    Examples:\n        &gt;&gt;&gt; bisect(f=lambda x: x*x - 4, a=0, b=4, tol=0.001)\n        Root(value=2.0, iterations=0, converged=True, tol=0.001)\n        &gt;&gt;&gt; root = bisect(\n        ... f=lambda x: x*x*x + 8, a=-7, b=-1, tol=1e-25, max_iterations=100\n        ... )\n        &gt;&gt;&gt; root.value\n        -2.0\n        &gt;&gt;&gt; root.converged\n        True\n\n    \"\"\"\n    iteration = 0\n    while iteration &lt; max_iterations:\n        c = (a + b) / 2\n        if ((b - a) / 2) &lt; tol or abs(fc := f(c)) &lt; tol:\n            return Root(value=c, iterations=iteration, converged=True, tol=tol)\n\n        if _same_sign(f(a), fc):\n            a = c\n        else:\n            b = c\n\n        iteration += 1\n\n    return Root(value=(a + b) / 2, iterations=iteration, converged=False, tol=tol)\n</code></pre>"}]}